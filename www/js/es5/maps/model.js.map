{"version":3,"sources":["model.js"],"names":["System","register","_export","_context","_classCallCheck","instance","Constructor","TypeError","_extend","View","Collection","_createClass","Model","setters","_underscore","extend","_view","_collection","execute","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","attrs","this","views","changeHooks","value","val","execChangeHooks","_key","push","object","view","splice","indexOf","collection","remove","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","err","func","get","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2"],"mappings":"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","file":"model.js","sourcesContent":["/* @flow */\nimport {extend} from 'underscore'\nimport View from './view'\nimport Collection from './collection'\n\ndeclare type hook = (val :mixed) => void\ndeclare type hookMap = {[key :string]: hook | Array<hook>}\n\n// Generic model class, that all other model classes extend\nexport default class Model {\n\tattrs :Object = {};\n\tviews :Array<View> = [];\n\tchangeHooks :hookMap = {};\n\tid :string;\n\tcollection: Collection;\n\n\tconstructor(attrs :?Object) {\n\t\tif (attrs) {\n\t\t\tthis.attrs = attrs\n\t\t}\n\t}\n\n\t// Retrieve a strored value of specific key from the model's attribute\n\t// object\n\tget(key :string) :mixed {\n\t\treturn this.attrs[key]\n\t}\n\n\t// Set a key to a target value\n\tset(key :string, val :mixed) {\n\t\tthis.attrs[key] = val\n\t\tthis.execChangeHooks(key)\n\t}\n\n\t// Extend the model attribute hash, with the suplied object. Shorthand, for\n\t// setting multiple fields simultaniously.\n\tsetAttrs(attrs :Object) {\n\t\textend(this.attrs, attrs)\n\t\tfor (let key in attrs) {\n\t\t\tthis.execChangeHooks(key)\n\t\t}\n\t}\n\n\t// Append value to an array strored at the given key. If the array does not\n\t// exist, it is created.\n\tappend(key :string, val :mixed) {\n\t\tif (this.attrs[key]) {\n\t\t\tthis.attrs[key].push(val)\n\t\t} else {\n\t\t\tthis.attrs[key] = [val]\n\t\t}\n\t\tthis.execChangeHooks(key)\n\t}\n\n\t// Extend an object at target key. If key does not exist, simply assign the\n\t// object to the key.\n\textend(key :string, object :Object) {\n\t\tif (this.attrs[key]) {\n\t\t\textend(this.attrs[key], object)\n\t\t} else {\n\t\t\tthis.attrs[key] = object\n\t\t}\n\t\tthis.execChangeHooks(key)\n\t}\n\n\t// Attach a view to a model. Simply adds the view to the model's view array.\n\t// Each model's method will then provide individual logic for calling the\n\tattach(view :View) {\n\t\tthis.views.push(view)\n\t}\n\n\t// Detach a view from the model. Removes reference, so model and/or view\n\t// can be garbage collected.\n\tdetach(view :View) {\n\t\tthis.views.splice(this.views.indexOf(view), 1)\n\t}\n\n\t// Remove the model from its collection, if any, and remove all its views\n\tremove() {\n\t\tif (this.collection) {\n\t\t\tthis.collection.remove(this)\n\t\t}\n\t\tfor (let view of this.views) {\n\t\t\tview.remove()\n\t\t}\n\t}\n\n\n\t// Add a function to be executed, when .set(), .setAttrs(), .append() or\n\t// .extend() modify a key's value.\n\tonChange(key :string, func :hook) {\n\t\tif (this.changeHooks[key]) {\n\t\t\tthis.changeHooks[key].push(func)\n\t\t} else {\n\t\t\tthis.changeHooks[key] = [func]\n\t\t}\n\t}\n\n\t// Execute handlers hooked into key change, if any\n\t// @param {string} key\n\texecChangeHooks(key :string) {\n\t\tif (!this.changeHooks[key]) {\n\t\t\treturn\n\t\t}\n\t\tconst val = this.get(key)\n\t\tfor (let func of this.changeHooks[key]) {\n\t\t\tfunc(val)\n\t\t}\n\t}\n}\n"],"sourceRoot":"/source/"}