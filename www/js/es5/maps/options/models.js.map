{"version":3,"sources":["options/models.js"],"names":["System","register","_export","_context","_classCallCheck","instance","Constructor","TypeError","extend","options","opts","_createClass","optionModels","OptionModel","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","spec","setters","_vendorUnderscore","_options","_opts","execute","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","model","_this","this","undefined","load","type","val","attrs","id","get","onChange","execOnStart","value","localStorage","getItem","stored","read","num","parseInt","set","exec","setItem","validation","Symbol","iterator","next","done","err"],"mappings":"AAAA,YAAaA,QAAOC,UAAU,0BAA0B,aAAa,UAAU,SAASC,EAAQC,GAAwJ,QAASC,GAAgBC,EAASC,GAAa,KAAKD,YAAoBC,IAAc,KAAM,IAAIC,WAAU,qCAAxP,GAAIC,GAAOC,EAAQC,EAAKC,EAAaC,EAAaC,EAAYC,EAA0BC,EAAkBC,EAAeC,EAAUC,EAAMC,CAAsJ,QAAQC,SAAS,SAASC,GAAmBb,EAAOa,EAAkBb,QAAS,SAASc,GAAUb,EAAQa,EAAAA,YAAmB,SAASC,GAAOb,EAAKa,EAAAA,aAAiBC,QAAQ,WAAWb,EAAa,WAAW,QAASc,GAAiBC,EAAOC,GAAO,IAAI,GAAIC,GAAE,EAAEA,EAAED,EAAME,OAAOD,IAAI,CAAC,GAAIE,GAAWH,EAAMC,EAAGE,GAAWC,WAAWD,EAAWC,aAAY,EAAMD,EAAWE,cAAa,EAAQ,SAAWF,KAAWA,EAAWG,UAAS,GAAKC,OAAOC,eAAeT,EAAOI,EAAWM,IAAIN,IAAc,MAAO,UAASxB,EAAY+B,EAAWC,GAAuI,MAAvHD,IAAWZ,EAAiBnB,EAAYiC,UAAUF,GAAeC,GAAYb,EAAiBnB,EAAYgC,GAAoBhC,MAAkBM,KAAgBV,EAAQ,UAAUU,GAAcC,EAAY,WAAW,QAASA,GAAY2B,GAAO,GAAIC,GAAMC,IAAuC,IAAlCtC,EAAgBsC,KAAK7B,GAA6B8B,SAAbH,EAAMI,MAAmBJ,EAAMI,KAAlC,CAAgDpC,EAAOkC,KAAKF,GAAWE,KAAKG,OAAMH,KAAKG,KAAK,WAAY,IAAIC,GAAIrC,EAAQsC,MAAML,KAAKM,IAAIN,KAAKO,KAAMxC,GAAQyC,SAASR,KAAKM,GAAG,SAASF,GAAK,MAAOL,GAAMS,SAASJ,KAAWJ,KAAKS,eAAc,GAAOT,KAAKlB,QAAQsB,GAAMlC,EAAa8B,KAAKM,IAAIN,MAAqtB,MAA/sB/B,GAAaE,IAAcuB,IAAI,OAAOgB,MAAM,WAAgB,MAAOC,cAAaC,QAAQZ,KAAKM,OAAQZ,IAAI,MAAMgB,MAAM,WAAe,GAAIG,GAAOb,KAAKc,MAAO,IAAID,EAAkC,CAAC,GAAY,UAATA,EAAkB,OAAO,CAAO,IAAY,SAATA,EAAiB,OAAO,CAAM,IAAIE,GAAIC,SAASH,EAAO,GAAI,OAAGE,IAAW,IAANA,EAAgBA,EAAYf,KAAAA,WAA/J,MAAOA,MAAAA,cAA0KN,IAAI,WAAWgB,MAAM,SAAkBN,GAAKJ,KAAKlB,QAAQsB,GAAKJ,KAAKiB,IAAIb,MAASV,IAAI,UAAUgB,MAAM,SAAiBN,GAAQJ,KAAKkB,MAAMlB,KAAKkB,KAAKd,MAAUV,IAAI,MAAMgB,MAAM,SAAaN,IAAQA,IAAMJ,KAAAA,YAAcA,KAAKc,SAAQH,aAAaQ,QAAQnB,KAAKM,GAAGF,MAAUV,IAAI,WAAWgB,MAAM,SAAkBN,GAAK,MAAGJ,MAAKoB,WAAmBpB,KAAKoB,WAAWhB,IAAa,MAAiBjC,KAAgBC,GAA0B,EAAKC,GAAkB,EAAMC,EAAe2B,MAAU,KAAI,IAAI1B,EAiH9xEP,EAAIqD,OAAAC,cAAAlD,GAAAI,EAAAD,EAAAgD,QAAAC,MAAApD,GAAA,EAAAK,EAAAD,EAAAkC,MAAA,GAAAvC,GAAAM,GAAA,MAAAgD,GAAApD,GAAA,EAAAC,EAAAmD,EAAA,QAAA,KAAArD,GAAAG,EAAAA,WAAAA,EAAAA,YAAA,QAAA,GAAAF,EAAA,KAAAC","file":"options/models.js","sourcesContent":["import {extend} from '../../vendor/underscore'\nimport options from '../options'\nimport opts from './opts'\n\n// All loaded option models\nconst optionModels = {}\nexport default optionModels\n\n/**\n * Coontroler for each individual option\n */\nclass OptionModel {\n\t/**\n\t * Create new option model from template model\n\t * @param {Object} model\n\t */\n\tconstructor(model) {\n\t\t// Condition for loading option. Optional.\n\t\tif (model.load !== undefined && !model.load) {\n\t\t\treturn\n\t\t}\n\t\textend(this, model)\n\n\t\t// No type = checkbox + default false\n\t\tif (!this.type) {\n\t\t\tthis.type = 'checkbox'\n\t\t}\n\n\t\t// Store option value in central stotage options Backbone model\n\t\tconst val = options.attrs[this.id] = this.get()\n\t\toptions.onChange(this.id, val =>\n\t\t\tthis.onChange(val))\n\t\tif (this.execOnStart !== false) {\n\t\t\tthis.execute(val)\n\t\t}\n\t\toptionModels[this.id] = this\n\t}\n\n\t/**\n\t * Read value from localStorage\n\t * @returns {string}\n\t */\n\tread() {\n\t\treturn localStorage.getItem(this.id)\n\t}\n\n\t/**\n\t * Retrieve option value from storage and parse result. If none, return\n\t * default.\n\t * @returns {string|bool|int}\n\t */\n\tget() {\n\t\tconst stored = this.read()\n\t\tif (!stored) {\n\t\t\treturn this.default\n\t\t} else {\n\t\t\tif (stored === 'false') {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif (stored === \"true\") {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tconst num = parseInt(stored, 10)\n\t\t\tif (num || num === 0) {\n\t\t\t\treturn num\n\t\t\t}\n\t\t\treturn this.default\n\t\t}\n\t}\n\n\t/**\n\t * Handler to be executed on field change in central options storage model\n\t * @param {*} val\n\t */\n\tonChange(val) {\n\t\tthis.execute(val)\n\t\tthis.set(val)\n\t}\n\n\t/**\n\t * Execute handler function, if any\n\t * @param {*} val\n\t */\n\texecute(val) {\n\t\tif (this.exec) {\n\t\t\tthis.exec(val)\n\t\t}\n\t}\n\n\t/**\n\t * Write value to localStorage, if needed\n\t * @param {*} val\n\t */\n\tset(val) {\n\t\tif (val !== this.default || this.read()) {\n\t\t\tlocalStorage.setItem(this.id, val)\n\t\t}\n\t}\n\n\t/**\n\t * Perform value validation, if any. Othervise return true.\n\t * @param {*} val\n\t * @returns {bool}\n\t */\n\tvalidate(val) {\n\t\tif (this.validation) {\n\t\t\treturn this.validation(val)\n\t\t}\n\t\treturn true\n\t}\n}\n\n// Create an option model for each object in the array\nfor (let spec of opts) {\n\tnew OptionModel(spec)\n}\n"],"sourceRoot":"/source/"}