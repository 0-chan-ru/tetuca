{"version":3,"sources":["memory.js"],"names":["System","register","_export","_context","_classCallCheck","instance","Constructor","TypeError","parseSet","set","val","undefined","JSON","parse","e","isObject","isEmpty","_size","Cookie","_createClass","memories","Memory","setters","_vendorUnderscore","size","_vendorJsCookie","execute","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","window","addEventListener","_ref","newValue","cached","expiry","_this","this","read","setTimeout","purgeExpired","value","Math","floor","Date","now","localStorage","removeItem","getItem","chached","purgeAll","setItem","stringify","writeAll","limit","expired","push","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","err"],"mappings":"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","file":"memory.js","sourcesContent":["import {isObject, isEmpty, size} from '../vendor/underscore'\nimport * as Cookie from '../vendor/js-cookie'\n\n// All instances of the Memory class\nconst memories = {}\n\n/**\n * Listen for storage events and update the stored value for exising memory\n * instances, if the key changes. These only fire, if the write happens in\n * another tab of the same origin.\n */\nwindow.addEventListener('storage', ({key, newValue}) => {\n\tif (key in memories) {\n\t\tmemories[key].cached = parseSet(newValue)\n\t}\n})\n\n/**\n * Parse a stringified set\n * @param {string} set\n * @returns {Object}\n */\nfunction parseSet(set) {\n\tlet val\n\ttry {\n\t\tval = JSON.parse(set)\n\t}\n\tcatch(e) {}\n\treturn isObject(val) ? val : {}\n}\n\n/**\n * Self-expiring localStorage set manager\n */\nexport default class Memory {\n\t/**\n\t * Construct a new localStorage controller\n\t * @param {string} key - localStorage key\n\t * @param {int} expiry - Entry lifetime in days\n\t */\n\tconstructor(key, expiry) {\n\t\tthis.key = key\n\t\tmemories[key] = this\n\t\tthis.expiry = expiry\n\n\t\t// Read the initial value\n\t\tthis.cached = this.read()\n\n\t\t// Purge old entries on start\n\t\tsetTimeout(() => this.purgeExpired(), 5000)\n\t}\n\n\t/**\n\t * Return current time in seconds\n\t * @returns {int}\n\t */\n\tnow() {\n\t\treturn Math.floor(Date.now() / 1000)\n\t}\n\n\t/**\n\t * Clear the stored set\n\t */\n\tpurgeAll() {\n\t\tlocalStorage.removeItem(this.key)\n\t}\n\n\t/**\n\t * Read and parse the stringified set from localStorage\n\t * @returns {Object}\n\t */\n\tread() {\n\t\tconst key = localStorage.getItem(this.key)\n\t\tif (!key) {\n\t\t\treturn {}\n\t\t}\n\t\treturn parseSet(key)\n\t}\n\n\t/**\n\t * Return, if the given jey exists in the set\n\t * @param {string} key\n\t * @returns {bool}\n\t */\n\thas(key) {\n\t    return !!this.chached[key]\n\t}\n\n\t/**\n\t * Replace the existing set, if any, with the suplied one\n\t * @param {Object} object\n\t */\n\twriteAll(set) {\n\t\tif (isEmpty(set)) {\n\t\t\treturn this.purgeAll()\n\t\t}\n\t\tlocalStorage.setItem(this.key, JSON.stringify(set))\n\t}\n\n\t/**\n\t * Write a single key to the stored set\n\t * @returns {int} - Size of new set\n\t */\n\twrite(key) {\n\t\t// When performing writes, best fetch everything, rather than rely on\n\t\t// events for browser tab cache synchronisation. Browser backround tab\n\t\t// optimisation might fuck us over.\n\t\tthis.cached = this.read()\n\t\tthis.cached[key] = this.now()\n\t\tthis.writeAll(this.cached)\n\t\treturn size(this.cached) // Return number of items\n\t}\n\n\t/**\n\t * Return the current size of the stored Set\n\t */\n\tsize() {\n\t\treturn size(this.cached)\n\t}\n\n\t/**\n\t * Delete expired entries from set and write to localStorage\n\t */\n\tpurgeExpired() {\n\t\tthis.chached = this.read(),\n\t\t\tnow = this.now(),\n\t\t\tlimit = 86400 * this.expiry,\n\t\t\texpired = []\n\t\tfor (let key in this.chached) {\n\t\t\tif (now > this.chached[key] + limit) {\n\t\t\t\texpired.push(key)\n\t\t\t}\n\t\t}\n\t\tif (!expired.length) {\n\t\t\treturn\n\t\t}\n\t\tfor (let key of expired) {\n\t\t    delete this.chached[key]\n\t\t}\n\t\tthis.writeAll(this.chached)\n\t}\n}\n"],"sourceRoot":"/source/"}