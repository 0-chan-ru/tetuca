{"version":3,"sources":["state.js"],"names":["System","register","_export","extend","Memory","$threads","randomID","syncs","ownPosts","mine","links","setters","_vendorUnderscore","_memory","_main","_util","execute","read","href","state","board","match","thread","lastN","_arr","_i","length","key","val","parseInt","clear","innerHTML","models","each","model","dispatch","posts","reset","exports","events","request","addLinks","addition"],"mappings":"AAAA,YAAaA,QAAOC,UAAU,uBAAuB,WAAW,SAAS,UAAU,SAASC,GAAS,GAAIC,GAAOC,EAAOC,EAASC,EAASC,EAAMC,EAASC,EAAKC,CAAM,QAAQC,SAAS,SAASC,GAAmBT,EAAOS,EAAkBT,QAAS,SAASU,GAAST,EAAOS,EAAAA,YAAkB,SAASC,GAAOT,EAASS,EAAMT,UAAW,SAASU,GAAOT,EAASS,EAAMT,WAAYU,QAAQ,WAAW,QAASC,GAAKC,GAAqL,IAAI,GAA/KC,IAAOC,MAAMF,EAAKG,MAAM,uBAAuB,GAAGC,OAAOJ,EAAKG,MAAM,sCAAsCE,MAAML,EAAKG,MAAM,oBAAwBG,GAAM,SAAS,SAAiBC,EAAG,EAAEA,EAAGD,EAAKE,OAAOD,IAiB9jB,CAAhC,GAAIE,GAAGH,EAAAC,GACLG,EAAMT,EAAMQ,EAAIR,GACbQ,GAAOC,EAAMC,SAASD,EAAI,IAAM,EACzC,MAAAT,GAAA,QAAAW,KAAAzB,EAAA0B,UAAA,GAAAC,OAAAC,KAAA,SAAAC,GAAA,MAAAA,GAAAC,SAAA,mBAAAC,MAAAC,QAAAC,QAAA/B,SAAAgC,OAAAC,QAAA,sBAAA,QAAAC,GAAAC,GAAAA,GAAAvC,EAAAO,EAAAgC,GAAAxC,EAAA,OAAAe,GAAAf,EAAA,QAAAK,MAAAL,EAAA,QAAAK,GAAAL,EAAA,WAAAM,MAAAN,EAAA,WAAAM,GAAAN,EAAA,OAAAO,EAAA,GAAAL,GAAA,OAAA,GAAA,IAAAF,EAAA,OAAAO,GAAAP,EAAA,QAAA4B,GAAA5B,EAAA,QAAAQ,MAAAR,EAAA,QAAAQ,GAAAR,EAAA,WAAAuC","file":"state.js","sourcesContent":["/*\n * Central model keeping the state of the page\n */\n\nimport {extend} from '../vendor/underscore'\nimport Memory from './memory'\nimport {$threads} from './main'\nimport {randomID} from './util'\n\n// Read page state by parsing a URL\nexport function read(href) {\n\tconst state = {\n\t\tboard: href.match(/\\/([a-zA-Z0-9]+?)\\//)[1],\n\t\tthread: href.match(/\\/(\\d+)(:?#\\d+)?(?:[\\?&]\\w+=\\w+)*$/),\n\t\t// Displayed last N posts setting on thread pages\n\t\tlastN: href.match(/[\\?&]last=(\\d+)/)\n\t}\n\tfor (let key of ['thread', 'lastN']) {\n\t\tconst val = state[key]\n\t    state[key] = val ? parseInt(val[1]) : 0\n\t}\n\treturn state\n}\n\n/*\n// Initial page state\nexport let page = new Backbone.Model(read(location.href))\npage.set('tabID', randomID(32))\n*/\n\n// Hot-reloadable configuration\n\n// TODO: We need actual listeners to this model for hot reloads\n\n// Tracks the synchronisation counter of each thread\nexport let syncs = {}\n\n// Posts I made in this tab\nexport const ownPosts = {}\n\n// Remember which posts are mine for two days\nexport const mine = new Memory('mine', 2, true)\n\n/*\n// All posts currently displayed\nexport const posts = new Backbone.Collection()\n*/\n\n/**\n * Clear the current post state and HTML\n */\nexport function clear() {\n\t/*\n\t * Emptying the whole element should be faster than removing each post\n\t * individually through models and listeners\n\t */\n\t$threads.innerHTML = ''\n\n\t// The <threads> tag has already been emptied, no need to perform\n\t// element removal with the default `.remove()` method\n\tmodels.each(model =>\n\t\tmodel.dispatch('stopListening'))\n\n\tposts.reset()\n\n\t// Prevent old threads from syncing\n\texports.syncs = {}\n\tevents.request('massExpander:unset')\n}\n\n// Post links verified server-side\nexport const links = {}\n\nexport function addLinks(addition) {\n\tif (addition) {\n\t\textend(links, addition);\n\t}\n}\n"],"sourceRoot":"/source/"}