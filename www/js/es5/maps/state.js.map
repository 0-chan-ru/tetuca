{"version":3,"sources":["state.js"],"names":["System","register","_export","extend","Backbone","Memory","$threads","randomID","radio","events","page","syncs","ownPosts","mine","posts","links","setters","_underscore","_backbone","_memory","_main","_util","_backboneRadio","execute","read","href","state","board","match","thread","lastN","_arr","_i","length","key","val","parseInt","clear","innerHTML","models","each","model","dispatch","reset","exports","request","addLinks","addition","init","channel","Model","location","set","Collection"],"mappings":"AAAA,YAAaA,QAAOC,UAAU,aAAa,WAAW,WAAW,OAAO,SAAS,kBAAkB,SAASC,GAAS,GAAIC,GAAOC,EAASC,EAAOC,EAASC,EAASC,EAAMC,EAAOC,EAAKC,EAAMC,EAASC,EAAKC,EAAMC,CAAM,QAAQC,SAAS,SAASC,GAAad,EAAOc,EAAYd,QAAS,SAASe,GAAWd,EAASc,GAAY,SAASC,GAASd,EAAOc,EAAAA,YAAkB,SAASC,GAAOd,EAASc,EAAMd,UAAW,SAASe,GAAOd,EAASc,EAAMd,UAAW,SAASe,GAAgBd,EAAMc,IAAkBC,QAAQ,WAAmF,QAASC,GAAKC,GAAqL,IAAI,GAA/KC,IAAOC,MAAMF,EAAKG,MAAM,uBAAuB,GAAGC,OAAOJ,EAAKG,MAAM,sCAAsCE,MAAML,EAAKG,MAAM,oBAAwBG,GAAM,SAAS,SAAiBC,EAAG,EAAEA,EAAGD,EAAKE,OAAOD,IAsBpwB,CAAhC,GAAIE,GAAGH,EAAAC,GACLG,EAAMT,EAAMQ,EAAIR,GACbQ,GAAOC,EAAMC,SAASD,EAAI,IAAM,EACzC,MAAAT,GAAA,QAAAW,KAAA/B,EAAAgC,UAAA,GAAAC,OAAAC,KAAA,SAAAC,GAAA,MAAAA,GAAAC,SAAA,mBAAA5B,EAAA6B,QAAAC,QAAAjC,SAAAF,EAAAoC,QAAA,sBAAA,QAAAC,GAAAC,GAAAA,GAAA5C,EAAAY,EAAAgC,GAAA,QAAAC,MAzBigB9C,EAAQ,SAASO,EAAOD,EAAMyC,QAAQ,SAAS/C,EAAQ,SAASO,GAyBjkBP,EAAA,OAAAsB,GAAAtB,EAAA,OAAAQ,EAAA,GAAAN,GAAA8C,MAAA1B,EAAA2B,SAAA1B,QAAAvB,EAAA,OAAAQ,GAAAA,EAAA0C,IAAA,QAAA7C,EAAA,KAAAL,EAAA,QAAAS,MAAAT,EAAA,QAAAS,GAAAT,EAAA,WAAAU,MAAAV,EAAA,WAAAU,GAAAV,EAAA,OAAAW,EAAA,GAAAR,GAAA,OAAA,GAAA,IAAAH,EAAA,OAAAW,GAAAX,EAAA,QAAAY,EAAA,GAAAV,GAAAiD,YAAAnD,EAAA,QAAAY,GAAAZ,EAAA,QAAAmC,GAAAnC,EAAA,QAAAa,MAAAb,EAAA,QAAAa,GAAAb,EAAA,WAAA4C,GAAA5C,EAAA,OAAA8C","file":"state.js","sourcesContent":["/*\n * Central model keeping the state of the page\n */\n\nimport {extend} from 'underscore'\nimport * as Backbone from 'backbone'\nimport Memory from './memory'\nimport {$threads} from 'main'\nimport {randomID} from './util'\nimport * as radio from 'backbone.radio'\n\n// Message and event bus\nexport const events = radio.channel('main')\n\n// Read page state by parsing a URL\nexport function read(href) {\n\tconst state = {\n\t\tboard: href.match(/\\/([a-zA-Z0-9]+?)\\//)[1],\n\t\tthread: href.match(/\\/(\\d+)(:?#\\d+)?(?:[\\?&]\\w+=\\w+)*$/),\n\t\t// Displayed last N posts setting on thread pages\n\t\tlastN: href.match(/[\\?&]last=(\\d+)/)\n\t}\n\tfor (let key of ['thread', 'lastN']) {\n\t\tconst val = state[key]\n\t    state[key] = val ? parseInt(val[1]) : 0\n\t}\n\treturn state\n}\n\n// Initial page state\nexport let page = new Backbone.Model(read(location.href))\npage.set('tabID', randomID(32))\n\n// Hot-reloadable configuration\n\n// TODO: We need actual listeners to this model for hot reloads\n\n// Tracks the synchronisation counter of each thread\nexport let syncs = {}\n\n// Posts I made in this tab\nexport const ownPosts = {}\n\n// remember which posts are mine for two days\nexport const mine = new Memory('mine', 2, true)\n\n// All posts currently displayed\nexport const posts = new Backbone.Collection()\n\n/**\n * Clear the current post state and HTML\n */\nexport function clear() {\n\t/*\n\t * Emptying the whole element should be faster than removing each post\n\t * individually through models and listeners\n\t */\n\t$threads.innerHTML = ''\n\n\t// The <threads> tag has already been emptied, no need to perform\n\t// element removal with the default `.remove()` method\n\tmodels.each(model =>\n\t\tmodel.dispatch('stopListening'))\n\n\tposts.reset()\n\n\t// Prevent old threads from syncing\n\texports.syncs = {}\n\tevents.request('massExpander:unset')\n}\n\n// Post links verified server-side\nexport const links = {}\n\nexport function addLinks(addition) {\n\tif (addition) {\n\t\textend(links, addition);\n\t}\n}\n\nexport function init() {\n\n}\n"],"sourceRoot":"/source/"}