{"version":3,"sources":["fsm.js"],"names":["System","register","_export","_context","_classCallCheck","instance","Constructor","TypeError","_createClass","FSM","setters","execute","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","start","this","state","spec","acts","ons","wilds","preflights","value","second","f","push","pres","trans_spec","on_func","halves","split","Error","parts","dest","match","tok","undefined","part","m","src","on","ev","param","from","to","ps","call","fs","_this","feed"],"mappings":"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","file":"fsm.js","sourcesContent":["// Finite State Machine\nexport default class FSM {\n    // Create a new finite state machine\n    constructor(start) {\n        this.state = start\n        this.spec = {\n            acts: {},\n            ons: {},\n            wilds: {},\n            preflights: {}\n        }\n    }\n\n    // Clone the current FSM\n    clone() {\n        const second = new FSM(this.state)\n        second.spec = this.spec\n        return second\n    }\n\n    // Assign a handler to be execute on arrival to a new state\n    on(key, f) {\n        const ons = this.spec.ons[key]\n        if (ons) {\n            ons.push(f)\n        } else {\n            this.spec.ons[key] = [f]\n        }\n    }\n\n    // Assign sanity check to perform before transition to a new state\n    preflight(key, f) {\n        const pres = this.spec.preflights[key]\n        if (pres) {\n            pres.push(f)\n        } else {\n            this.spec.preflights[key] = [f]\n        }\n    }\n\n    // Specify transition and an optional handler to execute on it\n    act(trans_spec, on_func) {\n        const halves = trans_spec.split('->')\n        if (halves.length != 2) {\n            throw new Error(\"Bad FSM spec: \" + trans_spec)\n        }\n        const parts = halves[0].split(','),\n            dest = halves[1].match(/^\\s*(\\w+)\\s*$/)[1]\n        let tok\n        for (let i = parts.length - 1; i >= 0; i--) {\n            const part = parts[i],\n                m = part.match(/^\\s*(\\*|\\w+)\\s*(?:\\+\\s*(\\w+)\\s*)?$/)\n            if (!m) {\n                throw new Error(\"Bad FSM spec portion: \" + part)\n            }\n            if (m[2]) {\n                tok = m[2]\n            }\n            if (!tok) {\n                throw new Error(\"Tokenless FSM action: \" + part)\n            }\n            const src = m[1]\n            if (src == '*') {\n                this.spec.wilds[tok] = dest\n            } else {\n                let acts = this.spec.acts[src]\n                if (!acts) {\n                    this.spec.acts[src] = acts = {}\n                }\n                acts[tok] = dest\n            }\n        }\n        if (on_func) {\n            this.on(dest, on_func)\n        }\n    }\n\n    // Transition the FSM to a new state\n    feed(ev, param) {\n        const {spec} = this,\n            from = this.state,\n            acts = spec.acts[from],\n            to = (acts && acts[ev]) || spec.wilds[ev]\n        if (to && from != to) {\n            const ps = spec.preflights[to]\n            for (let i = 0; ps && i < ps.length; i++) {\n                if (!ps[i].call(this, param)) {\n                    return false\n                }\n            }\n            this.state = to\n            const fs = spec.ons[to]\n            for (let i = 0; fs && i < fs.length; i++) {\n                fs[i].call(this, param)\n            }\n        }\n        return true\n    }\n\n    // Returns a function that executes FSM.prototype.feed with the suplied\n    // argument\n    feeder(ev) {\n        return param =>  this.feed(ev, param)\n    }\n}\n"],"sourceRoot":"/source/"}