{"version":3,"sources":["posts/render/body.js"],"names":["System","register","_export","_context","parseWord","word","data","split","html","i","length","state","bit","test","parsePostLink","links","parseReference","parseURL","escape","num","match","verified","renderPostLink","board","OP","name","href","refTargets","newTabLink","text","encodeURI","config","_slicedToArray","boards","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","_step3$value","link","setters","_state","_vendorUnderscore","_etc","execute","renderBody","renderFragment","body","dice","frag","lines","line","startsWith","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","value","err","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","push","Array","isArray","Object","TypeError","enabled","psuedo","concat"],"mappings":"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","file":"posts/render/body.js","sourcesContent":["import {config} from '../state'\nimport {escape} from '../../../vendor/underscore'\nimport {renderPostLink} from './etc'\n\n/**\n * Render the text body of a post\n * @param {Model} data\n * @returns {string}\n */\nexport function renderBody(data) {\n    if (!data.state) {\n        // Initial post state [new_line, no_qoute, no_spoiler, no_dice]\n        data.state = [0, 0, 0]\n    }\n    let html = renderFragment(data.body, data.state, data.dice)\n    if (data.state[1]) { // Close quote on post end\n        html += '</em>'\n    }\n    if (data.state[2]) { // Same with spoilers\n        html += '</del>'\n    }\n    return html\n}\n\n/**\n * Parse commited text body fragment\n * @param {string} frag\n * @param {Model} data\n * @returns {string}\n */\nexport function renderFragment(frag, data) {\n    const lines = frag.split('\\n'),\n        {state} = data\n    let html = ''\n    for (let i = 0; i < lines.length; i++) {\n        // Start a new line\n        if (state[0] && i % 2) {\n            // Close quoute\n            if (state[1] % 2) {\n                html += '</em>'\n                state[1]++\n            }\n            html += '<br>'\n            state[0] = 0\n        }\n\n        // Quote or line starts with link/embed\n        const line = lines[i]\n        if (!state[0] && line.startsWith('>')) {\n            html += '<em>'\n            state[1]++\n        }\n\n        // Bodies may be empty\n        if (frag) {\n            for (let word of line.split(' ')) {\n                html += parseWord(word, data)\n                state[0] = 1\n            }\n        }\n    }\n    return html\n}\n\n/**\n * Convert a word to it's appropriate HTML representation\n * @param {string} word\n * @param {Model} data\n * @returns {string}\n */\nfunction parseWord(word, data) {\n    // `[spoiler]` and `[/spoiler]` are treated the same way. You can't nest\n    // them.\n    const split = word.split(/\\[\\/?spoiler]/i)\n    let html = ''\n    for (let i = 0; i < split.length; i++) {\n        // Insert spoiler tags\n        if (i % 2) {\n            html += `<${data.state[2]++ % 2 ? '/' : ''}del>`\n\n            // TODO: Do we need special logic for postForms here?\n        }\n\n        const bit = split[i]\n        if (/^>>\\d+$/.test(bit)) {\n            // Post links\n            html += parsePostLink(bit, data.links)\n        } else if (/^>>>\\/\\w+\\//.test(bit)) {\n            // Internal and custom reference URLs\n            html += parseReference(bit)\n        } else if (/^https?:\\/\\/[^-A-Za-z0-9+&@#/%?=~_]$/.test(bit)) {\n            // Generic URLs\n            html += parseURL(bit)\n        } else if (/<strong>.+<\\/strong>/.test(bit)) {\n            // Hash command results. Already verified server-side.\n            html += bit\n        } else {\n            html += escape(bit)\n        }\n    }\n    return html\n}\n\n/**\n * Verify and render a link to other posts\n * @param {string} bit\n * @param {Object} links\n * @returns {string}\n */\nfunction parsePostLink(bit, links) {\n    if (!links) {\n        return bit\n    }\n    const num = bit.match(/^>>\\/(\\d+)$/)[1],\n        verified = links[num]\n    if (!verified) {\n        return bit\n    }\n    return renderPostLink(num, verified.board, verified.OP)\n}\n\n// Generate all possible refference name and link pairs\nconst refTargets = {},\n    {boards} = config\nfor (let board of boards.enabled) {\n    refTargets[board] = `../${board}/`\n}\nfor (let [name, link] of boards.psuedo.concat(boards.links)) {\n    refTargets[name] = link\n}\n\n/**\n * Parse internal or customly set reference URL\n * @param {string} bit\n * @returns {string}\n */\nfunction parseReference(bit) {\n    const name = bit.match(/^>>>\\/(\\w+)\\/$/)[1],\n        href = refTargets[name]\n    if (!href) {\n        return bit\n    }\n    return newTabLink(href, bit)\n}\n\n/**\n * Render and anchor link that opens in a new tab\n * @param {string} href\n * @param {text} href\n * @returns {string}\n */\nfunction newTabLink(href, text) {\n    return `<a href=\"${href}\" target=\"_blank\">${text}</a>`\n}\n\n/**\n * Render generic URLs and embed, if aplicable\n * @param {string} bit\n * @returns {string}\n */\nfunction parseURL(bit) {\n\n    // TODO: Embeds\n\n    return newTabLink(encodeURI(href), bit)\n}\n"],"sourceRoot":"/source/"}