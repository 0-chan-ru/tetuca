{"version":3,"sources":["client/history.js"],"names":["System","register","_export","_context","readingSteiner","url","event","nextState","state","read","_","isMatch","page","attributes","main","request","preventDefault","split","address","test","length","$loading","show","xhr","XMLHttpRequest","open","onload","this","status","hide","alert","baseURL","responseURL","trigger","$threads","innerHTML","response","set","oneeSama","op","thread","Extract","catalog","common","RESYNC","board","syncs","live","history","pushState","href","location","hash","window","scrollTo","send","$","setters","execute","require","$doc","on","ctrlKey","reply","onpopstate","target"],"mappings":"AAAA,YAAaA,QAAOC,YAAY,SAASC,EAAQC,GAoBjD,QAASC,GAAeC,EAAKC,GAC5B,GAAIC,GAAYC,EAAMC,KAAKJ,EADQ,KAG/BK,EAAEC,QAAQH,EAAMI,KAAKC,WAAYN,GAHF,CAGnCO,EAKKC,QAAQ,mBAETT,GACHA,EAAMU,gBADP,IAIMC,GAAQZ,EAAIY,MAAM,KACpBC,EAAUD,EAAM,IAAM,KAAKE,KAAKF,EAAM,IAAM,IAAM,KAAO,cACxC,KAAjBA,EAAMG,SACTF,GAAW,IAAMD,EAAM,IADxBI,EAQSC,MAxB0B,IAyB7BC,GAAM,GAAIC,eAzBmBD,GA0B/BE,KAAK,MAAOP,GA1BmBK,EA2B/BG,OAAS,WAGZ,MAAoB,OAAhBC,KAAKC,QACRP,EAASQ,OACFC,MAAMH,KAAKC,UAIfG,EAAQ1B,KAAS0B,EAAQJ,KAAKK,eACjCzB,EAAYC,EAAMC,KAAKkB,KAAKK,cAD7BlB,EAEKC,QAAQ,cAAe,QAXJD,EAYnBmB,QAAQ,eAZWnB,EAenBoB,SAAS,GAAGC,UAAYR,KAAKS,SAfV5B,EAkBlBI,KAAKyB,IAAI9B,GAlBSO,EAqBnBwB,SAASC,GAAKhC,EAAUiC,OArBL,GAsBpBC,GAAQlC,EAAUmC,SAIjBnC,EAAUmC,SACd5B,EAAKC,QAAQ,qBAAsB4B,EAAOC,OAAQrC,EAAUsC,MAC3DrC,EAAMsC,MAAOvC,EAAUwC,OAGrBzC,IACH0C,QAAQC,UAAU,KAAM,KAAM1C,EAAU2C,MAGpCC,SAASC,KACZtC,EAAKC,QAAQ,sBAEbsC,OAAOC,SAAS,EAAG,QAPrBjC,GASSQ,SAnEyBN,EAqE/BgC,QArEL,QAwESxB,GAAQ1B,GAChB,MAAOA,GAAIY,MAAM,SAAS,GA7FgC,GAAIH,GAAK0C,EAAE9C,EAAEiC,EAAOF,EAAQjC,EAAMa,CA4F7F,QAAAoC,WAAAC,QAAA,WAxFI5C,EAAO6C,QAAQ,UACjBH,EAAgC1C,EAAhC0C,EAAG9C,EAA6BI,EAA7BJ,EAAGiC,EAA0B7B,EAA1B6B,OAAQF,EAAkB3B,EAAlB2B,QAASjC,EAASM,EAATN,MAGzBM,EAAK8C,KAAKC,GAAI,QAAS,YAAa,SAASvD,GACxCA,EAAMwD,SAAV1D,EAEeuB,KAAKuB,KAAM5C,KAIvBe,EAAWmC,EAAE,iBACjB1C,EAAKiD,MAAM,eAAgB,WAAA,MAAM1C,GAASC,SAC1CR,EAAKiD,MAAM,eAAgB,WAAA,MAAM1C,GAASQ,SAgF1CwB,OAAOW,WAAa,SAAS1D,GAC5BF,EAAeE,EAAM2D,OAAOd,SAASD,MADFpC,EAE9BC,QAAQ","file":"client/history.js","sourcesContent":["/*\n * Inter board/page/thread navigation with HTML5 history\n */\n\nlet main = require('./main'),\n\t{$, _, common, Extract, state} = main;\n\n// Click handler for post/thread/board links\nmain.$doc.on ('click', 'a.history', function(event) {\n\tif (event.ctrlKey)\n\t\treturn;\n\treadingSteiner(this.href, event);\n});\n\n// Loading status GIF\nlet $loading = $('#loadingImage');\nmain.reply('loading:show', () => $loading.show());\nmain.reply('loading:hide', () => $loading.hide());\n\n// Navigate to the URL\nfunction readingSteiner(url, event) {\n\tlet nextState = state.read(url);\n\t// Does the link point to the same page as this one?\n\tif (_.isMatch(state.page.attributes, nextState))\n\t\treturn;\n\n\t// Disconnect server-side Yakusoku in preparation for navigating away.\n\t// This helps avoid duplicate messages mid-navigation.\n\tmain.request('connection:lock');\n\n\tif (event)\n\t\tevent.preventDefault();\n\n\t// Deal with hashes and query strings\n\tconst split = url.split('#');\n\tlet address = split[0] + (/\\?/.test(split[0]) ? '&' : '?') + 'minimal=true';\n\tif (split.length !== 1)\n\t\taddress += '#' + split[1];\n\n\t/*\n\t * Fetch new DOM from the server\n\t * Decided to go withthout dedicated caching and use etags for browser\n\t * cache verification.\n\t */\n\t$loading.show();\n\tconst xhr = new XMLHttpRequest();\n\txhr.open('GET', address);\n\txhr.onload = function () {\n\t\t// In case the thread is dead, moderatator cookie expired or some\n\t\t// other shenanigans\n\t\tif (this.status !== 200) {\n\t\t\t$loading.hide()\n\t\t\treturn alert(this.status)\n\t\t}\n\n\t\t// Was redirected to different thread/board\n\t\tif (baseURL(url) !== baseURL(this.responseURL))\n\t\t\tnextState = state.read(this.responseURL);\n\t\tmain.request('postSM:feed', 'done');\n\t\tmain.trigger('state:clear');\n\n\t\t// Apply new DOM and load models\n\t\tmain.$threads[0].innerHTML = this.response;\n\n\t\t// Set new page state\n\t\tstate.page.set(nextState);\n\n\t\t// Reconfigure rendering singleton\n\t\tmain.oneeSama.op = nextState.thread;\n\t\tnew Extract(nextState.catalog);\n\n\t\t// Swap the database controller server-side. Catalog does not use a\n\t\t// Yakusoku(), so not needed.\n\t\tif (!nextState.catalog) {\n\t\t\tmain.request('connection:unlock', [common.RESYNC, nextState.board,\n\t\t\t\tstate.syncs, nextState.live]);\n\t\t}\n\n\t\tif (event) {\n\t\t\thistory.pushState(null, null, nextState.href);\n\n\t\t\t// Scroll to top on new pages with no hashes\n\t\t\tif (location.hash)\n\t\t\t\tmain.request('scroll:aboveBanner');\n\t\t\telse\n\t\t\t\twindow.scrollTo(0, 0);\n\t\t}\n\t\t$loading.hide();\n\t};\n\txhr.send();\n}\n\nfunction baseURL(url) {\n\treturn url.split(/[\\?#]/)[0];\n}\n\n// For back and forward history events\nwindow.onpopstate = function(event) {\n\treadingSteiner(event.target.location.href);\n\tmain.request('scroll:aboveBanner');\n};\n"],"sourceRoot":"/source/"}