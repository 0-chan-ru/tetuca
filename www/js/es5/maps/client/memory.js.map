{"version":3,"sources":["client/memory.js"],"names":["System","register","_export","_context","_classCallCheck","instance","Constructor","TypeError","parseSet","set","val","JSON","parse","e","isEmpty","_size","_createClass","memories","Memory","setters","_underscore","size","execute","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","window","addEventListener","_ref","newValue","cached","expiry","_this","this","read","setTimeout","purgeExpired","value","Math","floor","Date","now","localStorage","removeItem","getItem","purgeAll","setItem","stringify","writeAll","limit","expired","push","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","err"],"mappings":"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","file":"client/memory.js","sourcesContent":["import {isEmpty, size} from 'underscore'\n\n// All instances of the Memory class\nconst memories = {}\n\n// Listen for storage events and update the stored value for exising memory\n// instances, if the key changes. These only fire, if the write happens in\n// another tab of the same origin.\nwindow.addEventListener('storage', ({key, newValue}) => {\n\tif (key in memories) {\n\t\tmemories[key].cached = parseSet(newValue)\n\t}\n})\n\n// Parse a stringified set\nfunction parseSet(set) {\n\tlet val = {}\n\ttry {\n\t\tval = JSON.parse(set)\n\t}\n\tcatch(e) {}\n\treturn val\n}\n\n// Self-expiring localStorage set manager\nexport default class Memory {\n\tconstructor(key, expiry) {\n\t\tthis.key = key\n\t\tmemories[key] = this\n\t\tthis.expiry = expiry\n\n\t\t// Read the initial value\n\t\tthis.cached = this.read()\n\n\t\t// Purge old entries on start\n\t\tsetTimeout(() => this.purgeExpired(), 5000)\n\t}\n\n\t// Return current time in seconds\n\tnow() {\n\t\treturn Math.floor(Date.now() / 1000)\n\t}\n\n\t// Clear the stored set\n\tpurgeAll() {\n\t\tlocalStorage.removeItem(this.key)\n\t}\n\n\t// Read and parse the stringified set from localStorage\n\tread() {\n\t\tconst key = localStorage.getItem(this.key)\n\t\tif (!key) {\n\t\t\treturn {}\n\t\t}\n\t\treturn parseSet(key)\n\t}\n\n\t// Return, if the given key exists in the set\n\thas(key) {\n\t\treturn !!this.cached[key]\n\t}\n\n\t// Replace the existing set, if any, with the suplied one\n\twriteAll(set) {\n\t\tif (isEmpty(set)) {\n\t\t\treturn this.purgeAll()\n\t\t}\n\t\tlocalStorage.setItem(this.key, JSON.stringify(set))\n\t}\n\n\t// Write a single key to the stored set\n\twrite(key) {\n\t\t// When performing writes, best fetch everything, rather than rely on\n\t\t// events for browser tab cache synchronisation. Browser backround tab\n\t\t// optimisation might fuck us over.\n\t\tthis.cached = this.read()\n\t\tthis.cached[key] = this.now()\n\t\tthis.writeAll(this.cached)\n\t\treturn size(this.cached) // Return number of items\n\t}\n\n\t// Return the current size of the stored Set\n\tsize() {\n\t\treturn size(this.cached)\n\t}\n\n\t// Delete expired entries from set and write to localStorage\n\tpurgeExpired() {\n\t\tthis.cached = this.read()\n\t\tconst now = this.now(),\n\t\t\tlimit = 86400 * this.expiry,\n\t\t\texpired = []\n\t\tfor (let key in this.cached) {\n\t\t\tif (now > this.cached[key] + limit) {\n\t\t\t\texpired.push(key)\n\t\t\t}\n\t\t}\n\t\tif (!expired.length) {\n\t\t\treturn\n\t\t}\n\t\tfor (let key of expired) {\n\t\t\tdelete this.cached[key]\n\t\t}\n\t\tthis.writeAll(this.cached)\n\t}\n}\n"],"sourceRoot":"/source/"}