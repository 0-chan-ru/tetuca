{"version":3,"sources":["scroll.js"],"names":["System","register","_export","_context","cacheState","lockIndicator","document","query","isThread","state","posts","get","checkBottom","height","body","scrollHeight","window","innerHeight","atBottom","scrollY","style","visibility","elExists","el","contains","topDistance","skipCheck","_el$getBoundingClient","getBoundingClientRect","top","referenceDistance","referenceEl","bounds","_arr","_i","length","selector","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","$threads","queryAll","Symbol","iterator","next","done","value","err","aboveBanner","test","location","hash","anchor","scrollTo","$banner","Backbone","options","events","setters","_main","execute","followDOM","func","previous","ret","hidden","delta","scrollBy","page","on","addEventListener","reply","onload"],"mappings":"AAAA,YAAaA,QAAOC,UAAU,QAAQ,SAASC,EAAQC,GAWvD,QAASC,KACRC,EAAgBC,SAASC,MAAM,SADVC,IAERC,EAAMC,MAAMC,IAAI,UAF9B,QAYSC,KACR,GAAMC,GAASP,SAASQ,KAAKC,aAAeC,OAAOC,WAD7BC,GAEXL,GAAUG,OAAOG,QACxBd,IACHA,EAAce,MAAMC,WAAaH,EAAW,UAAY,UAJ1D,QA8CSI,GAASC,GACjB,MAAOA,IAAMjB,SAASkB,SAASD,GADhC,QAWSE,GAAYF,EAAIG,GAAW,GAAAC,GACrBJ,EAAGK,wBAAVC,EAAAF,EAAAE,GAD4B,OAE/BH,IAAcG,GAAO,GAAKA,EAAMb,OAAOC,YACnCY,EAED,KALR,QAYSC,KACR,GAAIR,EAASS,GAAc,CAC1B,GAAMC,GAASP,EAAYM,EADD,IAEX,OAAXC,EACH,MAAOA,GAJmB,IAAA,GAC5BC,IASsB,UAAW,UAAW,WAVhBC,EAAA,EAU5BA,EAAAD,EAAAE,OAAAD,IAAwD,CAAnD,GAAIE,GAAAH,EAAAC,GAA+CG,GAAA,EAAAC,GAAA,EAAAC,EAAAC,MAAA,KACvD,IAAA,GAAeC,GAAfC,EAAeC,EAASC,SAASR,GAAlBS,OAAAC,cAAfT,GAAAI,EAAAC,EAAAK,QAAAC,MAAAX,GAAA,EAA4C,CAAA,GAAnCd,GAAAkB,EAAAQ,MACFjB,EAASP,EAAYF,EADgB,IAE5B,OAAXS,EAAiB,MACpBD,GAAcR,EACPS,GAJT,MAAAkB,GAAAZ,GAAA,EAAAC,EAAAW,EAAA,QAAA,KAAAb,GAAAK,EAAAA,WAAAA,EAAAA,YAAA,QAAA,GAAAJ,EAAA,KAAAC,MAXF,QAwBSY,KACR,GAAK,UAAUC,KAAKC,SAASC,MAA7B,CAAA,GAGMC,GAASjD,SAASC,MAAM8C,SAASC,KAClCC,IAALvC,OAGOwC,SAAS,EAAG/B,EAAY8B,GAAUE,EAAQ5C,SA5He,GAAI6C,GAASC,EAAQlD,EAAMkC,EAASc,EAAQG,EAAO1C,EAASb,EAAcG,EAASuB,CAoHpJ,QAAA8B,SAAA,SAAAC,GAhHQJ,EAAAI,EAAAJ,SAAUC,EAAAG,EAAAH,QAASlD,EAAAqD,EAAArD,MAAOkC,EAAAmB,EAAAnB,SAAUc,EAAAK,EAAAL,QAASG,EAAAE,EAAAF,SAAAG,QAAA,WAuC9C,QAASC,GAAUC,GACzB,GAAMC,GAAWpC,IAChBqC,EAAMF,GAFwB,KAK3B/C,GAAcZ,SAAS8D,SAAUT,EAAQhD,IAAI,cAE1C,CAEN,IAAKW,EAASS,GACb,MAAOoC,EADR,IAKME,GAAQ5C,EAAYM,GAAa,GAAQmC,CAC3CG,IACHrD,OAAOsD,SAAS,EAAGD,OAVpBrD,QAAOwC,SAAS,EAAIlD,SAASQ,KAAKC,aADnC,OAcOoD,GAxDJjD,EAAAsB,OAAUnC,EAAAmC,OAAehC,EAAAgC,OAW7B/B,EAAM8D,KAAKC,GAAG,SAAUpE,GACxBA,IAaAQ,IACAN,SAASmE,iBAAiB,SAAU7D,GAGhCmB,EAAAS,OAQGtC,EAAA,YAAA8D,GAmFPJ,EAAOc,MAAM,qBAAsBvB,GACnCnC,OAAO2D,OAASxB","file":"scroll.js","sourcesContent":["/*\n * Various page scrolling logic\n */\n\nimport {Backbone, options, state, $threads, $banner, events} from 'main'\n\nlet atBottom, lockIndicator, isThread\n\n/**\n * Write the current state to variables\n */\nfunction cacheState() {\n\tlockIndicator = document.query('#lock')\n\tisThread = !!state.posts.get('thread')\n}\n\n// Recache state on page change\nstate.page.on('change', cacheState)\ncacheState()\n\n/**\n * Set the scroll lock position to a post or to the bottom of the document\n */\nfunction checkBottom() {\n\tconst height = document.body.scrollHeight - window.innerHeight\n\tatBottom = height <= window.scrollY\n\tif (lockIndicator) {\n\t\tlockIndicator.style.visibility = atBottom ? 'visible' : 'hidden'\n\t}\n}\n\ncheckBottom()\ndocument.addEventListener('scroll', checkBottom)\n\n// Cache previous reference element to minimize DOM lookup\nlet referenceEl\n\n/**\n * Lock position to the bottom of a thread or keep the viewport from bumping\n * on out of sight DOM mutation.\n * @param {function} func\n * @returns {*}\n */\nexport function followDOM(func) {\n\tconst previous = referenceDistance(),\n\t\tret = func()\n\n\t// Prevent scrolling with new posts, if page isn't visible\n\tif (atBottom && (!document.hidden || options.get('alwaysLock'))) {\n\t\twindow.scrollTo(0,  document.body.scrollHeight)\n\t} else {\n\t\t// Element was removed or something\n\t\tif (!elExists(referenceEl)) {\n\t\t\treturn ret\n\t\t}\n\n\t\t// Only compensate, if the height increased above the viewport\n\t\tconst delta = topDistance(referenceEl, true) - previous\n\t\tif (delta) {\n\t\t\twindow.scrollBy(0, delta)\n\t\t}\n\t}\n\treturn ret\n}\n\n/**\n * Check if element reference exists and is in the DOM\n * @param {Element} el\n */\nfunction elExists(el) {\n\treturn el && document.contains(el)\n}\n\n/**\n * Return element position dimentions against the viewport, if the element\n * is withing the viewport\n * @param {Element} el\n * @param {bool} skipCheck\n * @returns {(Number|null)}\n */\nfunction topDistance(el, skipCheck) {\n\tconst {top} = el.getBoundingClientRect()\n\tif (skipCheck || (top >= 0 && top < window.innerHeight)) {\n\t\treturn top\n\t}\n\treturn null\n}\n\n/**\n * Returns distance of viewport to with current reference element\n * @returns {(Number|null)}\n */\nfunction referenceDistance() {\n\tif (elExists(referenceEl)) {\n\t\tconst bounds = topDistance(referenceEl)\n\t\tif (bounds !== null) {\n\t\t\treturn bounds\n\t\t}\n\t}\n\n\t// Find new reference element (first inside viewport). Account for empty\n\t// threads and boards with no artciles or sections.\n\tfor (let selector of ['article', 'section', 'threads']) {\n\t\tfor (let el of $threads.queryAll(selector)) {\n\t\t\tconst bounds = topDistance(el)\n\t\t\tif (bounds !== null) {\n\t\t\t\treferenceEl = el\n\t\t\t\treturn bounds\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Account for banner height, when scrolling to an anchor\n */\nfunction aboveBanner (){\n\tif (!/^#p\\d+$/.test(location.hash)) {\n\t\treturn\n\t}\n\tconst anchor = document.query(location.hash)\n\tif (!anchor) {\n\t\treturn\n\t}\n\twindow.scrollTo(0, topDistance(anchor) - $banner.height)\n}\nevents.reply('scroll:aboveBanner', aboveBanner)\nwindow.onload = aboveBanner\n"],"sourceRoot":"/source/"}