{"version":3,"sources":["scroll.js"],"names":[],"mappings":"qJAIQ,wBAAU,sBAAS,kBAAO,wBAAU,sBAAS,0CAErD,IAAI,QAAJ,CAAc,aAAd,CAA6B,QAA7B,CAKA,SAAS,UAAT,EAAsB,CACrB,cAAgB,SAAS,KAAT,CAAe,OAAf,CAAhB,CADqB,QAErB,CAAW,CAAC,CAAC,MAAM,KAAN,CAAY,GAAZ,CAAgB,QAAhB,CAAD,CAFS,CAAtB,KAMA,CAAM,IAAN,CAAW,EAAX,CAAc,QAAd,CAAwB,UAAxB,EACA,aAKA,SAAS,WAAT,EAAuB,CACtB,MAAM,OAAS,SAAS,IAAT,CAAc,YAAd,CAA6B,OAAO,WAAP,CADtB,QAEtB,CAAW,QAAU,OAAO,OAAP,CAFC,GAGlB,aAAJ,CAAmB,CAClB,cAAc,KAAd,CAAoB,UAApB,CAAiC,SAAW,SAAX,CAAuB,QAAvB,CADf,CAAnB,CAHD,WAQA,GACA,SAAS,gBAAT,CAA0B,QAA1B,CAAoC,WAApC,EAGA,IAAI,WAAJ,CAQO,SAAS,SAAT,CAAmB,IAAnB,CAAyB,CAC/B,MAAM,SAAW,mBAAX,CACL,IAAM,MAAN,CAF8B,GAK3B,WAAa,CAAC,SAAS,MAAT,EAAmB,QAAQ,GAAR,CAAY,YAAZ,CAApB,CAAb,CAA6D,CAChE,OAAO,QAAP,CAAgB,CAAhB,CAAoB,SAAS,IAAT,CAAc,YAAd,CAApB,CADgE,CAAjE,KAEO,CAEN,GAAI,CAAC,SAAS,WAAT,CAAD,CAAwB,CAC3B,OAAO,GAAP,CAD2B,CAA5B,MAKM,MAAQ,YAAY,WAAZ,CAAyB,IAAzB,EAAiC,QAAjC,CAPR,GAQF,KAAJ,CAAW,CACV,OAAO,QAAP,CAAgB,CAAhB,CAAmB,KAAnB,EADU,CAAX,CAVD,OAcO,GAAP,CAnB+B,CAAzB,+BA0BP,SAAS,QAAT,CAAkB,EAAlB,CAAsB,CACrB,OAAO,IAAM,SAAS,QAAT,CAAkB,EAAlB,CAAN,CADc,CAAtB,SAWS,WAAT,CAAqB,EAArB,CAAyB,SAAzB,CAAoC,2BACrB,GAAG,qBAAH,GADqB,MAC5B,8BAD4B,GAE/B,WAAc,KAAO,CAAP,EAAY,IAAM,OAAO,WAAP,CAAqB,CACxD,OAAO,GAAP,CADwD,CAAzD,OAGO,IAAP,CALmC,CAApC,SAYS,iBAAT,EAA6B,CAC5B,GAAI,SAAS,WAAT,CAAJ,CAA2B,CAC1B,MAAM,OAAS,YAAY,WAAZ,CAAT,CADoB,GAEtB,SAAW,IAAX,CAAiB,CACpB,OAAO,MAAP,CADoB,CAArB,CAFD,IASK,IAAI,QAAJ,IAAgB,CAAC,SAAD,CAAY,SAAZ,CAAuB,SAAvB,CAArB,CAAwD,CACvD,IAAK,IAAI,EAAJ,IAAU,SAAS,QAAT,CAAkB,QAAlB,CAAf,CAA4C,CAC3C,MAAM,OAAS,YAAY,EAAZ,CAAT,CADqC,GAEvC,SAAW,IAAX,CAAiB,CACpB,YAAc,EAAd,CADoB,OAEb,MAAP,CAFoB,CAArB,CAFD,CADD,CAVD,SAwBS,WAAT,EAAuB,CACtB,GAAI,CAAC,UAAU,IAAV,CAAe,SAAS,IAAT,CAAhB,CAAgC,CACnC,OADmC,CAApC,MAGM,OAAS,SAAS,KAAT,CAAe,SAAS,IAAT,CAAxB,CAJgB,GAKlB,CAAC,MAAD,CAAS,CACZ,OADY,CAAb,MAGA,CAAO,QAAP,CAAgB,CAAhB,CAAmB,YAAY,MAAZ,EAAsB,QAAQ,MAAR,CAAzC,CARsB,CAAvB,MAUA,CAAO,KAAP,CAAa,oBAAb,CAAmC,WAAnC,EACA,OAAO,MAAP,CAAgB,WAAhB","file":"scroll.js","sourcesContent":["/*\n * Various page scrolling logic\n */\n\nimport {Backbone, options, state, $threads, $banner, events} from 'main'\n\nlet atBottom, lockIndicator, isThread\n\n/**\n * Write the current state to variables\n */\nfunction cacheState() {\n\tlockIndicator = document.query('#lock')\n\tisThread = !!state.posts.get('thread')\n}\n\n// Recache state on page change\nstate.page.on('change', cacheState)\ncacheState()\n\n/**\n * Set the scroll lock position to a post or to the bottom of the document\n */\nfunction checkBottom() {\n\tconst height = document.body.scrollHeight - window.innerHeight\n\tatBottom = height <= window.scrollY\n\tif (lockIndicator) {\n\t\tlockIndicator.style.visibility = atBottom ? 'visible' : 'hidden'\n\t}\n}\n\ncheckBottom()\ndocument.addEventListener('scroll', checkBottom)\n\n// Cache previous reference element to minimize DOM lookup\nlet referenceEl\n\n/**\n * Lock position to the bottom of a thread or keep the viewport from bumping\n * on out of sight DOM mutation.\n * @param {function} func\n * @returns {*}\n */\nexport function followDOM(func) {\n\tconst previous = referenceDistance(),\n\t\tret = func()\n\n\t// Prevent scrolling with new posts, if page isn't visible\n\tif (atBottom && (!document.hidden || options.get('alwaysLock'))) {\n\t\twindow.scrollTo(0,  document.body.scrollHeight)\n\t} else {\n\t\t// Element was removed or something\n\t\tif (!elExists(referenceEl)) {\n\t\t\treturn ret\n\t\t}\n\n\t\t// Only compensate, if the height increased above the viewport\n\t\tconst delta = topDistance(referenceEl, true) - previous\n\t\tif (delta) {\n\t\t\twindow.scrollBy(0, delta)\n\t\t}\n\t}\n\treturn ret\n}\n\n/**\n * Check if element reference exists and is in the DOM\n * @param {Element} el\n */\nfunction elExists(el) {\n\treturn el && document.contains(el)\n}\n\n/**\n * Return element position dimentions against the viewport, if the element\n * is withing the viewport\n * @param {Element} el\n * @param {bool} skipCheck\n * @returns {(Number|null)}\n */\nfunction topDistance(el, skipCheck) {\n\tconst {top} = el.getBoundingClientRect()\n\tif (skipCheck || (top >= 0 && top < window.innerHeight)) {\n\t\treturn top\n\t}\n\treturn null\n}\n\n/**\n * Returns distance of viewport to with current reference element\n * @returns {(Number|null)}\n */\nfunction referenceDistance() {\n\tif (elExists(referenceEl)) {\n\t\tconst bounds = topDistance(referenceEl)\n\t\tif (bounds !== null) {\n\t\t\treturn bounds\n\t\t}\n\t}\n\n\t// Find new reference element (first inside viewport). Account for empty\n\t// threads and boards with no artciles or sections.\n\tfor (let selector of ['article', 'section', 'threads']) {\n\t\tfor (let el of $threads.queryAll(selector)) {\n\t\t\tconst bounds = topDistance(el)\n\t\t\tif (bounds !== null) {\n\t\t\t\treferenceEl = el\n\t\t\t\treturn bounds\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Account for banner height, when scrolling to an anchor\n */\nfunction aboveBanner (){\n\tif (!/^#p\\d+$/.test(location.hash)) {\n\t\treturn\n\t}\n\tconst anchor = document.query(location.hash)\n\tif (!anchor) {\n\t\treturn\n\t}\n\twindow.scrollTo(0, topDistance(anchor) - $banner.height)\n}\nevents.reply('scroll:aboveBanner', aboveBanner)\nwindow.onload = aboveBanner\n"],"sourceRoot":"/source/"}