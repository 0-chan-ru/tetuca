{"version":3,"sources":["model.js"],"names":[],"mappings":"iKAAQ,4CACD,2CACA,qDAGQ,MAAM,KAAN,CACd,aAAwB,KAAZ,oDAAQ,gBAAI,IACvB,CAAK,KAAL,CAAa,KAAb,CADuB,IAEvB,CAAK,KAAL,CAAa,EAAb,CAFuB,IAGvB,CAAK,WAAL,CAAmB,EAAnB,CAHuB,CAAxB,GAQA,CAAI,GAAJ,CAAS,CACR,OAAO,KAAK,KAAL,CAAW,GAAX,CAAP,CADQ,CAAT,GAKA,CAAI,GAAJ,CAAS,GAAT,CAAc,CACb,KAAK,KAAL,CAAW,GAAX,EAAkB,GAAlB,CADa,IAEb,CAAK,eAAL,CAAqB,GAArB,EAFa,CAAd,QAOA,CAAS,KAAT,CAAgB,CACf,OAAO,KAAK,KAAL,CAAY,KAAnB,EADe,IAEV,IAAI,GAAJ,IAAW,KAAhB,CAAuB,CACtB,KAAK,eAAL,CAAqB,GAArB,EADsB,CAAvB,CAFD,MASA,CAAO,GAAP,CAAY,GAAZ,CAAiB,CAChB,GAAI,KAAK,KAAL,CAAW,GAAX,CAAJ,CAAqB,CACpB,KAAK,KAAL,CAAW,GAAX,EAAgB,IAAhB,CAAqB,GAArB,EADoB,CAArB,KAEO,CACN,KAAK,KAAL,CAAW,GAAX,EAAkB,CAAC,GAAD,CAAlB,CADM,CAFP,IAKA,CAAK,eAAL,CAAqB,GAArB,EANgB,CAAjB,MAWA,CAAO,GAAP,CAAY,MAAZ,CAAoB,CACnB,GAAI,KAAK,KAAL,CAAW,GAAX,CAAJ,CAAqB,CACpB,OAAO,KAAK,KAAL,CAAW,GAAX,CAAP,CAAwB,MAAxB,EADoB,CAArB,KAEO,CACN,KAAK,KAAL,CAAW,GAAX,EAAkB,MAAlB,CADM,CAFP,IAKA,CAAK,eAAL,CAAqB,GAArB,EANmB,CAApB,MAWA,CAAO,IAAP,CAAa,CACZ,KAAK,KAAL,CAAW,IAAX,CAAgB,IAAhB,EADY,CAAb,MAMA,CAAO,IAAP,CAAa,CACZ,KAAK,KAAL,CAAW,MAAX,CAAkB,KAAK,KAAL,CAAW,OAAX,CAAmB,IAAnB,CAAlB,CAA4C,CAA5C,EADY,CAAb,MAKA,EAAS,CACR,GAAI,KAAK,UAAL,CAAiB,CACpB,KAAK,UAAL,CAAgB,MAAhB,CAAuB,IAAvB,EADoB,CAArB,IAGK,IAAI,IAAJ,IAAY,KAAK,KAAL,CAAY,CAC5B,KAAK,MAAL,GAD4B,CAA7B,CAJD,QAYA,CAAS,GAAT,CAAc,IAAd,CAAoB,CACnB,GAAI,KAAK,WAAL,CAAiB,GAAjB,CAAJ,CAA2B,CAC1B,KAAK,WAAL,CAAiB,GAAjB,EAAsB,IAAtB,CAA2B,IAA3B,EAD0B,CAA3B,KAEO,CACN,KAAK,WAAL,CAAiB,GAAjB,EAAwB,CAAC,IAAD,CAAxB,CADM,CAFP,CADD,eAUA,CAAgB,GAAhB,CAAqB,CACpB,GAAI,CAAC,KAAK,WAAL,CAAiB,GAAjB,CAAD,CAAwB,CAC3B,OAD2B,CAA5B,MAGM,IAAM,KAAK,GAAL,CAAS,GAAT,CAAN,CAJc,IAKf,IAAI,IAAJ,IAAY,KAAK,WAAL,CAAiB,GAAjB,CAAjB,CAAwC,CACvC,KAAK,GAAL,EADuC,CAAxC,CALD,CArFc,kBAAM","file":"model.js","sourcesContent":["import {extend} from 'underscore'\nimport View from './view'\nimport Collection from './collection'\n\n// Generic model class, that all other model classes extend\nexport default class Model {\n\tconstructor(attrs = {}) {\n\t\tthis.attrs = attrs\n\t\tthis.views = []\n\t\tthis.changeHooks = {}\n\t}\n\n\t// Retrieve a strored value of specific key from the model's attribute\n\t// object\n\tget(key) {\n\t\treturn this.attrs[key]\n\t}\n\n\t// Set a key to a target value\n\tset(key, val) {\n\t\tthis.attrs[key] = val\n\t\tthis.execChangeHooks(key)\n\t}\n\n\t// Extend the model attribute hash, with the suplied object. Shorthand, for\n\t// setting multiple fields simultaniously.\n\tsetAttrs(attrs) {\n\t\textend(this.attrs, attrs)\n\t\tfor (let key in attrs) {\n\t\t\tthis.execChangeHooks(key)\n\t\t}\n\t}\n\n\t// Append value to an array strored at the given key. If the array does not\n\t// exist, it is created.\n\tappend(key, val) {\n\t\tif (this.attrs[key]) {\n\t\t\tthis.attrs[key].push(val)\n\t\t} else {\n\t\t\tthis.attrs[key] = [val]\n\t\t}\n\t\tthis.execChangeHooks(key)\n\t}\n\n\t// Extend an object at target key. If key does not exist, simply assign the\n\t// object to the key.\n\textend(key, object) {\n\t\tif (this.attrs[key]) {\n\t\t\textend(this.attrs[key], object)\n\t\t} else {\n\t\t\tthis.attrs[key] = object\n\t\t}\n\t\tthis.execChangeHooks(key)\n\t}\n\n\t// Attach a view to a model. Simply adds the view to the model's view array.\n\t// Each model's method will then provide individual logic for calling the\n\tattach(view) {\n\t\tthis.views.push(view)\n\t}\n\n\t// Detach a view from the model. Removes reference, so model and/or view\n\t// can be garbage collected.\n\tdetach(view) {\n\t\tthis.views.splice(this.views.indexOf(view), 1)\n\t}\n\n\t// Remove the model from its collection, if any, and remove all its views\n\tremove() {\n\t\tif (this.collection) {\n\t\t\tthis.collection.remove(this)\n\t\t}\n\t\tfor (let view of this.views) {\n\t\t\tview.remove()\n\t\t}\n\t}\n\n\n\t// Add a function to be executed, when .set(), .setAttrs(), .append() or\n\t// .extend() modify a key's value.\n\tonChange(key, func) {\n\t\tif (this.changeHooks[key]) {\n\t\t\tthis.changeHooks[key].push(func)\n\t\t} else {\n\t\t\tthis.changeHooks[key] = [func]\n\t\t}\n\t}\n\n\t// Execute handlers hooked into key change, if any\n\t// @param {string} key\n\texecChangeHooks(key) {\n\t\tif (!this.changeHooks[key]) {\n\t\t\treturn\n\t\t}\n\t\tconst val = this.get(key)\n\t\tfor (let func of this.changeHooks[key]) {\n\t\t\tfunc(val)\n\t\t}\n\t}\n}\n"],"sourceRoot":"/source/"}