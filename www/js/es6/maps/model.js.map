{"version":3,"sources":["model.js"],"names":[],"mappings":"6NAUgB,KAAK,+CAAG,EAAE","file":"model.js","sourcesContent":["import {extend} from '../vendor/underscore'\n\n/**\n * Generic model class, that all other model classes extend\n */\nexport default class Model {\n    /**\n     * Constructs a new model object with the specified attribute object\n     * @param {Object} attrs\n     */\n    constructor(attrs = {}) {\n        this.attrs = attrs\n        this.views = []\n        this.changeHooks = {}\n    }\n\n    /**\n     * Retrieve a strored value of specific key from the model's attribute\n     * object\n     * @param {string} key\n     * @returns {*}\n     */\n    get(key) {\n        return this.attrs[key]\n    }\n\n    /**\n     * Set a key to a target value\n     * @param {string} key\n     * @param {*} val\n     */\n    set(key, val) {\n        this.attrs[key] = val\n        this.execChangeHooks(key)\n    }\n\n    /**\n     * Extend the model attribute hash, with the suplied object. Shorthand, for\n     * setting multiple fields simultaniously.\n     * @param {Object} attrs\n     */\n    setAttrs(attrs) {\n        extend(this.attrs, attrs)\n        for (let key in attrs) {\n            this.execChangeHooks(key)\n        }\n    }\n\n    /**\n     * Append value to an array strored at the given key. If the array does not\n     * exist, it is created.\n     * @param {string} key\n     * @param {*} val\n     */\n    append(key, val) {\n        if (this.attrs[key]) {\n            this.attrs[key].push(val)\n        } else {\n            this.attrs[key] = [val]\n        }\n        this.execChangeHooks(key)\n    }\n\n    /**\n     * Extend an object at target key. If key does not exist, simply assign the\n     * object to the key.\n     * @param {string} key\n     * @param {Object} object\n     */\n    extend(key, object) {\n        if (this.attrs[key]) {\n            extend(this.attrs[key], object)\n        } else {\n            this.attrs[key] = object\n        }\n        this.execChangeHooks(key)\n    }\n\n    /**\n     * Attach a view to a model. Simply adds the view to the model's view array.\n     * Each model's method will then provide individual logic for calling the\n     * attached views' methods.\n     * @param {View} view\n     */\n    attach(view) {\n        this.views.push(view)\n    }\n\n    /**\n     * Detach a view from the model. Removes reference, so model and/or view\n     * can be garbage collected.\n     * @param {View} view\n     */\n    detach(view) {\n        this.views.splice(this.views.indexOf(view), 1)\n    }\n\n    /**\n     * Remove the model from its collection, if any, and remove all its views\n     */\n    remove() {\n        if (this.collection) {\n            this.collection.remove(this)\n        }\n        for (let view of this.views) {\n            view.remove()\n        }\n    }\n\n    /**\n     * Add a function to be executed, when .set(), .setAttrs(), .append() or\n     * .extend() modify a key's value.\n     * @param {string} key\n     * @param {function} func\n     */\n    onChange(key, func) {\n        if (this.changeHooks[key]) {\n            this.changeHooks[key].push(func)\n        } else {\n            this.changeHooks[key] = [func]\n        }\n    }\n\n    /**\n     * Execute handlers hooked into key change, if any\n     * @param {string} key\n     */\n    execChangeHooks(key) {\n        if (!this.changeHooks[key]) {\n            return\n        }\n        const val = this.get(key)\n        for (let func of this.changeHooks[key]) {\n            func(val)\n        }\n    }\n}\n"],"sourceRoot":"/source/"}