{"version":3,"sources":["client/state.js"],"names":[],"mappings":"6MAIQ,8CACD,yCACC,wBAAU,qCACX,6CACA,qDAGA,SAAS,IAAT,CAAc,IAAd,CAAoB,CAC1B,MAAM,MAAQ,CACb,MAAO,KAAK,KAAL,CAAW,qBAAX,EAAkC,CAAlC,CAAP,CACA,OAAQ,KAAK,KAAL,CAAW,oCAAX,CAAR,CAEA,MAAO,KAAK,KAAL,CAAW,iBAAX,CAAP,CAJK,CADoB,IAOrB,IAAI,GAAJ,IAAW,CAAC,QAAD,CAAW,OAAX,CAAhB,CAAqC,CACpC,MAAM,IAAM,MAAM,GAAN,CAAN,CAD8B,KAEpC,CAAM,GAAN,EAAa,IAAM,SAAS,IAAI,CAAJ,CAAT,CAAN,CAAyB,CAAzB,CAFuB,CAArC,OAIO,KAAP,CAX0B,CAApB,qBAeP,MAAM,QAAU,KAAK,SAAS,IAAT,CAAf,CACN,QAAQ,KAAR,CAAgB,SAAS,EAAT,CAAhB,CACO,IAAI,KAAO,IAAI,KAAJ,CAAU,OAAV,CAAP,sBAOJ,IAAI,MAAQ,EAAR,wBAGJ,MAAM,SAAW,EAAX,8BAGN,MAAM,OAAS,OAAO,MAAP,0BAGf,MAAM,WAAa,OAAO,UAAP,kCAGnB,MAAM,SAAW,OAAO,QAAP,8BAGjB,MAAM,QAAU,SAAS,KAAT,CAAe,SAAf,CAAV,4BACN,MAAM,MAAQ,SAAS,KAAT,CAAe,OAAf,CAAR,wBACN,MAAM,OAAS,SAAS,KAAT,CAAe,QAAf,CAAT,0BACN,MAAM,QAAU,SAAS,KAAT,CAAe,SAAf,CAAV,4BAGN,MAAM,KAAO,IAAI,MAAJ,CAAW,MAAX,CAAmB,CAAnB,CAAP,sBAGN,MAAM,MAAQ,IAAI,UAAJ,EAAR,wBAGN,SAAS,KAAT,EAAiB,CAKvB,SAAS,SAAT,CAAqB,EAArB,CALuB,MASvB,CAAO,IAAP,CAAY,SACX,MAAM,QAAN,CAAe,eAAf,CADW,CAAZ,CATuB,KAYvB,CAAM,KAAN,GAZuB,OAevB,CAAQ,KAAR,CAAgB,EAAhB,CAfuB,MAgBvB,CAAO,OAAP,CAAe,oBAAf,EAhBuB,CAAjB,uBAoBA,SAAS,QAAT,CAAkB,EAAlB,CAAsB,CAC5B,MAAM,GAAK,MAAM,EAAN,CAAL,CADsB,GAExB,CAAC,EAAD,CAAK,CACR,OAAO,IAAP,CADQ,CAAT,OAGO,MAAM,GAAN,CAAU,EAAV,CAAP,CAL4B,CAAtB","file":"client/state.js","sourcesContent":["/*\n * Central model keeping the state of the page\n */\n\nimport {extend} from 'underscore'\nimport Memory from './memory'\nimport {randomID, getID} from './util'\nimport Model from './model'\nimport Collection from './collection'\n\n// Read page state by parsing a URL\nexport function read(href) {\n\tconst state = {\n\t\tboard: href.match(/\\/([a-zA-Z0-9]+?)\\//)[1],\n\t\tthread: href.match(/\\/(\\d+)(:?#\\d+)?(?:[\\?&]\\w+=\\w+)*$/),\n\t\t// Displayed last N posts setting on thread pages\n\t\tlastN: href.match(/[\\?&]last=(\\d+)/)\n\t}\n\tfor (let key of ['thread', 'lastN']) {\n\t\tconst val = state[key]\n\t\tstate[key] = val ? parseInt(val[1]) : 0\n\t}\n\treturn state\n}\n\n// Initial page state\nconst initial = read(location.href)\ninitial.tabID = randomID(32)\nexport let page = new Model(initial)\n\n// Hot-reloadable configuration\n\n// TODO: We need actual listeners to this model for hot reloads\n\n// Tracks the synchronisation counter of each thread\nexport let syncs = {}\n\n// Posts I made in this tab\nexport const ownPosts = {}\n\n// Configuration object, passed from the server\nexport const config = window.config\n\n// Hash of the the configuration object\nexport const configHash = window.configHash\n\n// Indicates, if in mobile mode. Determined server-side.\nexport const isMobile = window.isMobile\n\n// Cached DOM elements\nexport const $thread = document.query('threads')\nexport const $name = document.query('#name')\nexport const $email = document.query('#email')\nexport const $banner = document.query('#banner')\n\n// Remember which posts are mine for two days\nexport const mine = new Memory('mine', 2)\n\n// All posts currently displayed\nexport const posts = new Collection()\n\n// Clear the current post state and HTML\nexport function clear() {\n\t/*\n\t * Emptying the whole element should be faster than removing each post\n\t * individually through models and listeners\n\t */\n\t$threads.innerHTML = ''\n\n\t// The <threads> tag has already been emptied, no need to perform\n\t// element removal with the default `.remove()` method\n\tmodels.each(model =>\n\t\tmodel.dispatch('stopListening'))\n\n\tposts.reset()\n\n\t// Prevent old threads from syncing\n\texports.syncs = {}\n\tevents.request('massExpander:unset')\n}\n\n// Retrieve model of closest parent post\nexport function getModel(el) {\n\tconst id = getID(el)\n\tif (!id) {\n\t\treturn null\n\t}\n\treturn posts.get(id)\n}\n"],"sourceRoot":"/source/"}