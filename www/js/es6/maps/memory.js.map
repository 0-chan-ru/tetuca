{"version":3,"sources":["memory.js"],"names":[],"mappings":"+HAAQ,4BAAS,4CAGjB,MAAM,SAAW,EAAX,CAKN,OAAO,gBAAP,CAAwB,SAAxB,CAAmC,QAAqB,KAAnB,aAAmB,IAAd,uBAAc,GACnD,OAAO,QAAP,CAAiB,CACpB,SAAS,GAAT,EAAc,MAAd,CAAuB,SAAS,QAAT,CAAvB,CADoB,CAArB,CADkC,CAAnC,CAOA,SAAS,QAAT,CAAkB,GAAlB,CAAuB,CACtB,IAAI,IAAM,EAAN,CADkB,GAElB,CACH,IAAM,KAAK,KAAL,CAAW,GAAX,CAAN,CADG,CAAJ,MAGM,CAAN,CAAS,EAAT,OACO,GAAP,CANsB,CAAvB,MAUqB,MAAN,CACd,YAAY,GAAZ,CAAiB,MAAjB,CAAyB,CACxB,KAAK,GAAL,CAAW,GAAX,CADwB,QAExB,CAAS,GAAT,EAAgB,IAAhB,CAFwB,IAGxB,CAAK,MAAL,CAAc,MAAd,CAHwB,IAMxB,CAAK,MAAL,CAAc,KAAK,IAAL,EAAd,CANwB,UASxB,CAAW,MAAM,KAAK,YAAL,EAAN,CAA2B,IAAtC,EATwB,CAAzB,GAaA,EAAM,CACL,OAAO,KAAK,KAAL,CAAW,KAAK,GAAL,GAAa,IAAb,CAAlB,CADK,CAAN,QAKA,EAAW,CACV,aAAa,UAAb,CAAwB,KAAK,GAAL,CAAxB,CADU,CAAX,IAKA,EAAO,CACN,MAAM,IAAM,aAAa,OAAb,CAAqB,KAAK,GAAL,CAA3B,CADA,GAEF,CAAC,GAAD,CAAM,CACT,OAAO,EAAP,CADS,CAAV,OAGO,SAAS,GAAT,CAAP,CALM,CAAP,GASA,CAAI,GAAJ,CAAS,CACR,OAAO,CAAC,CAAC,KAAK,MAAL,CAAY,GAAZ,CAAD,CADA,CAAT,QAKA,CAAS,GAAT,CAAc,CACb,GAAI,QAAQ,GAAR,CAAJ,CAAkB,CACjB,OAAO,KAAK,QAAL,EAAP,CADiB,CAAlB,YAGA,CAAa,OAAb,CAAqB,KAAK,GAAL,CAAU,KAAK,SAAL,CAAe,GAAf,CAA/B,EAJa,CAAd,KAQA,CAAM,GAAN,CAAW,CAIV,KAAK,MAAL,CAAc,KAAK,IAAL,EAAd,CAJU,IAKV,CAAK,MAAL,CAAY,GAAZ,EAAmB,KAAK,GAAL,EAAnB,CALU,IAMV,CAAK,QAAL,CAAc,KAAK,MAAL,CAAd,CANU,OAOH,KAAK,KAAK,MAAL,CAAZ,CAPU,CAAX,IAWA,EAAO,CACN,OAAO,KAAK,KAAK,MAAL,CAAZ,CADM,CAAP,YAKA,EAAe,CACd,KAAK,MAAL,CAAc,KAAK,IAAL,EAAd,CADc,MAER,IAAM,KAAK,GAAL,EAAN,CACL,MAAQ,MAAQ,KAAK,MAAL,CAChB,QAAU,EAAV,CAJa,IAKT,IAAI,GAAJ,IAAW,KAAK,MAAL,CAAa,CAC5B,GAAI,IAAM,KAAK,MAAL,CAAY,GAAZ,EAAmB,KAAnB,CAA0B,CACnC,QAAQ,IAAR,CAAa,GAAb,EADmC,CAApC,CADD,GAKI,CAAC,QAAQ,MAAR,CAAgB,CACpB,OADoB,CAArB,IAGK,IAAI,GAAJ,IAAW,OAAhB,CAAyB,CACxB,OAAO,KAAK,MAAL,CAAY,GAAZ,CAAP,CADwB,CAAzB,IAGA,CAAK,QAAL,CAAc,KAAK,MAAL,CAAd,CAhBc,CAAf,CA9Dc,kBAAM","file":"memory.js","sourcesContent":["import {isEmpty, size} from 'underscore'\n\n// All instances of the Memory class\nconst memories = {}\n\n// Listen for storage events and update the stored value for exising memory\n// instances, if the key changes. These only fire, if the write happens in\n// another tab of the same origin.\nwindow.addEventListener('storage', ({key, newValue}) => {\n\tif (key in memories) {\n\t\tmemories[key].cached = parseSet(newValue)\n\t}\n})\n\n// Parse a stringified set\nfunction parseSet(set) {\n\tlet val = {}\n\ttry {\n\t\tval = JSON.parse(set)\n\t}\n\tcatch(e) {}\n\treturn val\n}\n\n// Self-expiring localStorage set manager\nexport default class Memory {\n\tconstructor(key, expiry) {\n\t\tthis.key = key\n\t\tmemories[key] = this\n\t\tthis.expiry = expiry\n\n\t\t// Read the initial value\n\t\tthis.cached = this.read()\n\n\t\t// Purge old entries on start\n\t\tsetTimeout(() => this.purgeExpired(), 5000)\n\t}\n\n\t// Return current time in seconds\n\tnow() {\n\t\treturn Math.floor(Date.now() / 1000)\n\t}\n\n\t// Clear the stored set\n\tpurgeAll() {\n\t\tlocalStorage.removeItem(this.key)\n\t}\n\n\t// Read and parse the stringified set from localStorage\n\tread() {\n\t\tconst key = localStorage.getItem(this.key)\n\t\tif (!key) {\n\t\t\treturn {}\n\t\t}\n\t\treturn parseSet(key)\n\t}\n\n\t// Return, if the given key exists in the set\n\thas(key) {\n\t\treturn !!this.cached[key]\n\t}\n\n\t// Replace the existing set, if any, with the suplied one\n\twriteAll(set) {\n\t\tif (isEmpty(set)) {\n\t\t\treturn this.purgeAll()\n\t\t}\n\t\tlocalStorage.setItem(this.key, JSON.stringify(set))\n\t}\n\n\t// Write a single key to the stored set\n\twrite(key) {\n\t\t// When performing writes, best fetch everything, rather than rely on\n\t\t// events for browser tab cache synchronisation. Browser backround tab\n\t\t// optimisation might fuck us over.\n\t\tthis.cached = this.read()\n\t\tthis.cached[key] = this.now()\n\t\tthis.writeAll(this.cached)\n\t\treturn size(this.cached) // Return number of items\n\t}\n\n\t// Return the current size of the stored Set\n\tsize() {\n\t\treturn size(this.cached)\n\t}\n\n\t// Delete expired entries from set and write to localStorage\n\tpurgeExpired() {\n\t\tthis.cached = this.read()\n\t\tconst now = this.now(),\n\t\t\tlimit = 86400 * this.expiry,\n\t\t\texpired = []\n\t\tfor (let key in this.cached) {\n\t\t\tif (now > this.cached[key] + limit) {\n\t\t\t\texpired.push(key)\n\t\t\t}\n\t\t}\n\t\tif (!expired.length) {\n\t\t\treturn\n\t\t}\n\t\tfor (let key of expired) {\n\t\t\tdelete this.cached[key]\n\t\t}\n\t\tthis.writeAll(this.cached)\n\t}\n}\n"],"sourceRoot":"/source/"}